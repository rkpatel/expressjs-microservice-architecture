'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var tslib = require('tslib');
var coreLro = require('@azure/core-lro');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
(function (KnownDeletionRecoveryLevel) {
    KnownDeletionRecoveryLevel["Purgeable"] = "Purgeable";
    KnownDeletionRecoveryLevel["RecoverablePurgeable"] = "Recoverable+Purgeable";
    KnownDeletionRecoveryLevel["Recoverable"] = "Recoverable";
    KnownDeletionRecoveryLevel["RecoverableProtectedSubscription"] = "Recoverable+ProtectedSubscription";
})(exports.KnownDeletionRecoveryLevel || (exports.KnownDeletionRecoveryLevel = {}));
(function (KnownJsonWebKeyType) {
    KnownJsonWebKeyType["EC"] = "EC";
    KnownJsonWebKeyType["ECHSM"] = "EC-HSM";
    KnownJsonWebKeyType["RSA"] = "RSA";
    KnownJsonWebKeyType["RSAHSM"] = "RSA-HSM";
})(exports.KnownJsonWebKeyType || (exports.KnownJsonWebKeyType = {}));
(function (KnownJsonWebKeyOperation) {
    KnownJsonWebKeyOperation["Encrypt"] = "encrypt";
    KnownJsonWebKeyOperation["Decrypt"] = "decrypt";
    KnownJsonWebKeyOperation["Sign"] = "sign";
    KnownJsonWebKeyOperation["Verify"] = "verify";
    KnownJsonWebKeyOperation["WrapKey"] = "wrapKey";
    KnownJsonWebKeyOperation["UnwrapKey"] = "unwrapKey";
    KnownJsonWebKeyOperation["Import"] = "import";
})(exports.KnownJsonWebKeyOperation || (exports.KnownJsonWebKeyOperation = {}));
(function (KnownJsonWebKeyCurveName) {
    KnownJsonWebKeyCurveName["P256"] = "P-256";
    KnownJsonWebKeyCurveName["P384"] = "P-384";
    KnownJsonWebKeyCurveName["P521"] = "P-521";
    KnownJsonWebKeyCurveName["P256K"] = "P-256K";
})(exports.KnownJsonWebKeyCurveName || (exports.KnownJsonWebKeyCurveName = {}));
(function (KnownSkuFamily) {
    KnownSkuFamily["A"] = "A";
})(exports.KnownSkuFamily || (exports.KnownSkuFamily = {}));
(function (KnownKeyPermissions) {
    KnownKeyPermissions["All"] = "all";
    KnownKeyPermissions["Encrypt"] = "encrypt";
    KnownKeyPermissions["Decrypt"] = "decrypt";
    KnownKeyPermissions["WrapKey"] = "wrapKey";
    KnownKeyPermissions["UnwrapKey"] = "unwrapKey";
    KnownKeyPermissions["Sign"] = "sign";
    KnownKeyPermissions["Verify"] = "verify";
    KnownKeyPermissions["Get"] = "get";
    KnownKeyPermissions["List"] = "list";
    KnownKeyPermissions["Create"] = "create";
    KnownKeyPermissions["Update"] = "update";
    KnownKeyPermissions["Import"] = "import";
    KnownKeyPermissions["Delete"] = "delete";
    KnownKeyPermissions["Backup"] = "backup";
    KnownKeyPermissions["Restore"] = "restore";
    KnownKeyPermissions["Recover"] = "recover";
    KnownKeyPermissions["Purge"] = "purge";
})(exports.KnownKeyPermissions || (exports.KnownKeyPermissions = {}));
(function (KnownSecretPermissions) {
    KnownSecretPermissions["All"] = "all";
    KnownSecretPermissions["Get"] = "get";
    KnownSecretPermissions["List"] = "list";
    KnownSecretPermissions["Set"] = "set";
    KnownSecretPermissions["Delete"] = "delete";
    KnownSecretPermissions["Backup"] = "backup";
    KnownSecretPermissions["Restore"] = "restore";
    KnownSecretPermissions["Recover"] = "recover";
    KnownSecretPermissions["Purge"] = "purge";
})(exports.KnownSecretPermissions || (exports.KnownSecretPermissions = {}));
(function (KnownCertificatePermissions) {
    KnownCertificatePermissions["All"] = "all";
    KnownCertificatePermissions["Get"] = "get";
    KnownCertificatePermissions["List"] = "list";
    KnownCertificatePermissions["Delete"] = "delete";
    KnownCertificatePermissions["Create"] = "create";
    KnownCertificatePermissions["Import"] = "import";
    KnownCertificatePermissions["Update"] = "update";
    KnownCertificatePermissions["Managecontacts"] = "managecontacts";
    KnownCertificatePermissions["Getissuers"] = "getissuers";
    KnownCertificatePermissions["Listissuers"] = "listissuers";
    KnownCertificatePermissions["Setissuers"] = "setissuers";
    KnownCertificatePermissions["Deleteissuers"] = "deleteissuers";
    KnownCertificatePermissions["Manageissuers"] = "manageissuers";
    KnownCertificatePermissions["Recover"] = "recover";
    KnownCertificatePermissions["Purge"] = "purge";
    KnownCertificatePermissions["Backup"] = "backup";
    KnownCertificatePermissions["Restore"] = "restore";
})(exports.KnownCertificatePermissions || (exports.KnownCertificatePermissions = {}));
(function (KnownStoragePermissions) {
    KnownStoragePermissions["All"] = "all";
    KnownStoragePermissions["Get"] = "get";
    KnownStoragePermissions["List"] = "list";
    KnownStoragePermissions["Delete"] = "delete";
    KnownStoragePermissions["Set"] = "set";
    KnownStoragePermissions["Update"] = "update";
    KnownStoragePermissions["Regeneratekey"] = "regeneratekey";
    KnownStoragePermissions["Recover"] = "recover";
    KnownStoragePermissions["Purge"] = "purge";
    KnownStoragePermissions["Backup"] = "backup";
    KnownStoragePermissions["Restore"] = "restore";
    KnownStoragePermissions["Setsas"] = "setsas";
    KnownStoragePermissions["Listsas"] = "listsas";
    KnownStoragePermissions["Getsas"] = "getsas";
    KnownStoragePermissions["Deletesas"] = "deletesas";
})(exports.KnownStoragePermissions || (exports.KnownStoragePermissions = {}));
(function (KnownNetworkRuleBypassOptions) {
    KnownNetworkRuleBypassOptions["AzureServices"] = "AzureServices";
    KnownNetworkRuleBypassOptions["None"] = "None";
})(exports.KnownNetworkRuleBypassOptions || (exports.KnownNetworkRuleBypassOptions = {}));
(function (KnownNetworkRuleAction) {
    KnownNetworkRuleAction["Allow"] = "Allow";
    KnownNetworkRuleAction["Deny"] = "Deny";
})(exports.KnownNetworkRuleAction || (exports.KnownNetworkRuleAction = {}));
(function (KnownVaultProvisioningState) {
    KnownVaultProvisioningState["Succeeded"] = "Succeeded";
    KnownVaultProvisioningState["RegisteringDns"] = "RegisteringDns";
})(exports.KnownVaultProvisioningState || (exports.KnownVaultProvisioningState = {}));
(function (KnownPrivateEndpointServiceConnectionStatus) {
    KnownPrivateEndpointServiceConnectionStatus["Pending"] = "Pending";
    KnownPrivateEndpointServiceConnectionStatus["Approved"] = "Approved";
    KnownPrivateEndpointServiceConnectionStatus["Rejected"] = "Rejected";
    KnownPrivateEndpointServiceConnectionStatus["Disconnected"] = "Disconnected";
})(exports.KnownPrivateEndpointServiceConnectionStatus || (exports.KnownPrivateEndpointServiceConnectionStatus = {}));
(function (KnownActionsRequired) {
    KnownActionsRequired["None"] = "None";
})(exports.KnownActionsRequired || (exports.KnownActionsRequired = {}));
(function (KnownPrivateEndpointConnectionProvisioningState) {
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    KnownPrivateEndpointConnectionProvisioningState["Updating"] = "Updating";
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
    KnownPrivateEndpointConnectionProvisioningState["Disconnected"] = "Disconnected";
})(exports.KnownPrivateEndpointConnectionProvisioningState || (exports.KnownPrivateEndpointConnectionProvisioningState = {}));
(function (KnownIdentityType) {
    KnownIdentityType["User"] = "User";
    KnownIdentityType["Application"] = "Application";
    KnownIdentityType["ManagedIdentity"] = "ManagedIdentity";
    KnownIdentityType["Key"] = "Key";
})(exports.KnownIdentityType || (exports.KnownIdentityType = {}));
(function (KnownProvisioningState) {
    /** The managed HSM Pool has been full provisioned. */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** The managed HSM Pool is currently being provisioned. */
    KnownProvisioningState["Provisioning"] = "Provisioning";
    /** Provisioning of the managed HSM Pool has failed. */
    KnownProvisioningState["Failed"] = "Failed";
    /** The managed HSM Pool is currently being updated. */
    KnownProvisioningState["Updating"] = "Updating";
    /** The managed HSM Pool is currently being deleted. */
    KnownProvisioningState["Deleting"] = "Deleting";
    /** The managed HSM pool is ready for normal use. */
    KnownProvisioningState["Activated"] = "Activated";
    /** The managed HSM pool is waiting for a security domain restore action. */
    KnownProvisioningState["SecurityDomainRestore"] = "SecurityDomainRestore";
    /** The managed HSM pool is being restored from full HSM backup. */
    KnownProvisioningState["Restoring"] = "Restoring";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
(function (KnownPublicNetworkAccess) {
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
(function (KnownManagedHsmSkuFamily) {
    KnownManagedHsmSkuFamily["B"] = "B";
})(exports.KnownManagedHsmSkuFamily || (exports.KnownManagedHsmSkuFamily = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const KeyCreateParameters = {
    type: {
        name: "Composite",
        className: "KeyCreateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "KeyProperties"
                }
            }
        }
    }
};
const KeyProperties = {
    type: {
        name: "Composite",
        className: "KeyProperties",
        modelProperties: {
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            kty: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            keyOps: {
                serializedName: "keyOps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            keySize: {
                serializedName: "keySize",
                type: {
                    name: "Number"
                }
            },
            curveName: {
                serializedName: "curveName",
                type: {
                    name: "String"
                }
            },
            keyUri: {
                serializedName: "keyUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            keyUriWithVersion: {
                serializedName: "keyUriWithVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyAttributes = {
    type: {
        name: "Composite",
        className: "KeyAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            notBefore: {
                serializedName: "nbf",
                type: {
                    name: "Number"
                }
            },
            expires: {
                serializedName: "exp",
                type: {
                    name: "Number"
                }
            },
            created: {
                serializedName: "created",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            updated: {
                serializedName: "updated",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            recoveryLevel: {
                serializedName: "recoveryLevel",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            exportable: {
                serializedName: "exportable",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyListResult = {
    type: {
        name: "Composite",
        className: "KeyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Key"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VaultCreateOrUpdateParameters = {
    type: {
        name: "Composite",
        className: "VaultCreateOrUpdateParameters",
        modelProperties: {
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "VaultProperties"
                }
            }
        }
    }
};
const VaultProperties = {
    type: {
        name: "Composite",
        className: "VaultProperties",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            accessPolicies: {
                serializedName: "accessPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AccessPolicyEntry"
                        }
                    }
                }
            },
            vaultUri: {
                serializedName: "vaultUri",
                type: {
                    name: "String"
                }
            },
            hsmPoolResourceId: {
                serializedName: "hsmPoolResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            enabledForDeployment: {
                serializedName: "enabledForDeployment",
                type: {
                    name: "Boolean"
                }
            },
            enabledForDiskEncryption: {
                serializedName: "enabledForDiskEncryption",
                type: {
                    name: "Boolean"
                }
            },
            enabledForTemplateDeployment: {
                serializedName: "enabledForTemplateDeployment",
                type: {
                    name: "Boolean"
                }
            },
            enableSoftDelete: {
                defaultValue: true,
                serializedName: "enableSoftDelete",
                type: {
                    name: "Boolean"
                }
            },
            softDeleteRetentionInDays: {
                defaultValue: 90,
                serializedName: "softDeleteRetentionInDays",
                type: {
                    name: "Number"
                }
            },
            enableRbacAuthorization: {
                defaultValue: false,
                serializedName: "enableRbacAuthorization",
                type: {
                    name: "Boolean"
                }
            },
            createMode: {
                serializedName: "createMode",
                type: {
                    name: "Enum",
                    allowedValues: ["recover", "default"]
                }
            },
            enablePurgeProtection: {
                serializedName: "enablePurgeProtection",
                type: {
                    name: "Boolean"
                }
            },
            networkAcls: {
                serializedName: "networkAcls",
                type: {
                    name: "Composite",
                    className: "NetworkRuleSet"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                type: {
                    name: "String"
                }
            },
            privateEndpointConnections: {
                serializedName: "privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnectionItem"
                        }
                    }
                }
            },
            publicNetworkAccess: {
                defaultValue: "enabled",
                serializedName: "publicNetworkAccess",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            family: {
                serializedName: "family",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["standard", "premium"]
                }
            }
        }
    }
};
const AccessPolicyEntry = {
    type: {
        name: "Composite",
        className: "AccessPolicyEntry",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            objectId: {
                serializedName: "objectId",
                required: true,
                type: {
                    name: "String"
                }
            },
            applicationId: {
                serializedName: "applicationId",
                type: {
                    name: "Uuid"
                }
            },
            permissions: {
                serializedName: "permissions",
                type: {
                    name: "Composite",
                    className: "Permissions"
                }
            }
        }
    }
};
const Permissions = {
    type: {
        name: "Composite",
        className: "Permissions",
        modelProperties: {
            keys: {
                serializedName: "keys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            secrets: {
                serializedName: "secrets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            certificates: {
                serializedName: "certificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            storage: {
                serializedName: "storage",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const NetworkRuleSet = {
    type: {
        name: "Composite",
        className: "NetworkRuleSet",
        modelProperties: {
            bypass: {
                serializedName: "bypass",
                type: {
                    name: "String"
                }
            },
            defaultAction: {
                serializedName: "defaultAction",
                type: {
                    name: "String"
                }
            },
            ipRules: {
                serializedName: "ipRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPRule"
                        }
                    }
                }
            },
            virtualNetworkRules: {
                serializedName: "virtualNetworkRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkRule"
                        }
                    }
                }
            }
        }
    }
};
const IPRule = {
    type: {
        name: "Composite",
        className: "IPRule",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkRule = {
    type: {
        name: "Composite",
        className: "VirtualNetworkRule",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            ignoreMissingVnetServiceEndpoint: {
                serializedName: "ignoreMissingVnetServiceEndpoint",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const PrivateEndpointConnectionItem = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Vault = {
    type: {
        name: "Composite",
        className: "Vault",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "VaultProperties"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const VaultPatchParameters = {
    type: {
        name: "Composite",
        className: "VaultPatchParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "VaultPatchProperties"
                }
            }
        }
    }
};
const VaultPatchProperties = {
    type: {
        name: "Composite",
        className: "VaultPatchProperties",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "Uuid"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            accessPolicies: {
                serializedName: "accessPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AccessPolicyEntry"
                        }
                    }
                }
            },
            enabledForDeployment: {
                serializedName: "enabledForDeployment",
                type: {
                    name: "Boolean"
                }
            },
            enabledForDiskEncryption: {
                serializedName: "enabledForDiskEncryption",
                type: {
                    name: "Boolean"
                }
            },
            enabledForTemplateDeployment: {
                serializedName: "enabledForTemplateDeployment",
                type: {
                    name: "Boolean"
                }
            },
            enableSoftDelete: {
                serializedName: "enableSoftDelete",
                type: {
                    name: "Boolean"
                }
            },
            enableRbacAuthorization: {
                serializedName: "enableRbacAuthorization",
                type: {
                    name: "Boolean"
                }
            },
            softDeleteRetentionInDays: {
                serializedName: "softDeleteRetentionInDays",
                type: {
                    name: "Number"
                }
            },
            createMode: {
                serializedName: "createMode",
                type: {
                    name: "Enum",
                    allowedValues: ["recover", "default"]
                }
            },
            enablePurgeProtection: {
                serializedName: "enablePurgeProtection",
                type: {
                    name: "Boolean"
                }
            },
            networkAcls: {
                serializedName: "networkAcls",
                type: {
                    name: "Composite",
                    className: "NetworkRuleSet"
                }
            },
            publicNetworkAccess: {
                serializedName: "publicNetworkAccess",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VaultAccessPolicyParameters = {
    type: {
        name: "Composite",
        className: "VaultAccessPolicyParameters",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "VaultAccessPolicyProperties"
                }
            }
        }
    }
};
const VaultAccessPolicyProperties = {
    type: {
        name: "Composite",
        className: "VaultAccessPolicyProperties",
        modelProperties: {
            accessPolicies: {
                serializedName: "accessPolicies",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AccessPolicyEntry"
                        }
                    }
                }
            }
        }
    }
};
const VaultListResult = {
    type: {
        name: "Composite",
        className: "VaultListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Vault"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedVaultListResult = {
    type: {
        name: "Composite",
        className: "DeletedVaultListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedVault"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedVault = {
    type: {
        name: "Composite",
        className: "DeletedVault",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DeletedVaultProperties"
                }
            }
        }
    }
};
const DeletedVaultProperties = {
    type: {
        name: "Composite",
        className: "DeletedVaultProperties",
        modelProperties: {
            vaultId: {
                serializedName: "vaultId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            deletionDate: {
                serializedName: "deletionDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            scheduledPurgeDate: {
                serializedName: "scheduledPurgeDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            tags: {
                serializedName: "tags",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            purgeProtectionEnabled: {
                serializedName: "purgeProtectionEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ResourceListResult = {
    type: {
        name: "Composite",
        className: "ResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Resource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VaultCheckNameAvailabilityParameters = {
    type: {
        name: "Composite",
        className: "VaultCheckNameAvailabilityParameters",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "Microsoft.KeyVault/vaults",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityResult = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityResult",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["AccountNameInvalid", "AlreadyExists"]
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const ManagedHsmProperties = {
    type: {
        name: "Composite",
        className: "ManagedHsmProperties",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "Uuid"
                }
            },
            initialAdminObjectIds: {
                serializedName: "initialAdminObjectIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            hsmUri: {
                serializedName: "hsmUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            enableSoftDelete: {
                defaultValue: true,
                serializedName: "enableSoftDelete",
                type: {
                    name: "Boolean"
                }
            },
            softDeleteRetentionInDays: {
                defaultValue: 90,
                serializedName: "softDeleteRetentionInDays",
                type: {
                    name: "Number"
                }
            },
            enablePurgeProtection: {
                defaultValue: true,
                serializedName: "enablePurgeProtection",
                type: {
                    name: "Boolean"
                }
            },
            createMode: {
                serializedName: "createMode",
                type: {
                    name: "Enum",
                    allowedValues: ["recover", "default"]
                }
            },
            statusMessage: {
                serializedName: "statusMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            networkAcls: {
                serializedName: "networkAcls",
                type: {
                    name: "Composite",
                    className: "MhsmNetworkRuleSet"
                }
            },
            privateEndpointConnections: {
                serializedName: "privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MhsmPrivateEndpointConnectionItem"
                        }
                    }
                }
            },
            publicNetworkAccess: {
                serializedName: "publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            scheduledPurgeDate: {
                serializedName: "scheduledPurgeDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const MhsmNetworkRuleSet = {
    type: {
        name: "Composite",
        className: "MhsmNetworkRuleSet",
        modelProperties: {
            bypass: {
                serializedName: "bypass",
                type: {
                    name: "String"
                }
            },
            defaultAction: {
                serializedName: "defaultAction",
                type: {
                    name: "String"
                }
            },
            ipRules: {
                serializedName: "ipRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MhsmipRule"
                        }
                    }
                }
            },
            virtualNetworkRules: {
                serializedName: "virtualNetworkRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MhsmVirtualNetworkRule"
                        }
                    }
                }
            }
        }
    }
};
const MhsmipRule = {
    type: {
        name: "Composite",
        className: "MhsmipRule",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmVirtualNetworkRule = {
    type: {
        name: "Composite",
        className: "MhsmVirtualNetworkRule",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmPrivateEndpointConnectionItem = {
    type: {
        name: "Composite",
        className: "MhsmPrivateEndpointConnectionItem",
        modelProperties: {
            privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "MhsmPrivateEndpoint"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "MhsmPrivateLinkServiceConnectionState"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmPrivateEndpoint = {
    type: {
        name: "Composite",
        className: "MhsmPrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmPrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "MhsmPrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedHsmResource = {
    type: {
        name: "Composite",
        className: "ManagedHsmResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "ManagedHsmSku"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const ManagedHsmSku = {
    type: {
        name: "Composite",
        className: "ManagedHsmSku",
        modelProperties: {
            family: {
                serializedName: "family",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Standard_B1", "Custom_B32"]
                }
            }
        }
    }
};
const ManagedHsmError = {
    type: {
        name: "Composite",
        className: "ManagedHsmError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            innerError: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const ManagedHsmListResult = {
    type: {
        name: "Composite",
        className: "ManagedHsmListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedHsm"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmPrivateEndpointConnectionsListResult = {
    type: {
        name: "Composite",
        className: "MhsmPrivateEndpointConnectionsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MhsmPrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedManagedHsmListResult = {
    type: {
        name: "Composite",
        className: "DeletedManagedHsmListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedManagedHsm"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedManagedHsm = {
    type: {
        name: "Composite",
        className: "DeletedManagedHsm",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DeletedManagedHsmProperties"
                }
            }
        }
    }
};
const DeletedManagedHsmProperties = {
    type: {
        name: "Composite",
        className: "DeletedManagedHsmProperties",
        modelProperties: {
            mhsmId: {
                serializedName: "mhsmId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            deletionDate: {
                serializedName: "deletionDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            scheduledPurgeDate: {
                serializedName: "scheduledPurgeDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            purgeProtectionEnabled: {
                serializedName: "purgeProtectionEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            tags: {
                serializedName: "tags",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const MhsmPrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "MhsmPrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MhsmPrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ServiceSpecification"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceSpecification = {
    type: {
        name: "Composite",
        className: "ServiceSpecification",
        modelProperties: {
            logSpecifications: {
                serializedName: "logSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LogSpecification"
                        }
                    }
                }
            },
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification"
                        }
                    }
                }
            }
        }
    }
};
const LogSpecification = {
    type: {
        name: "Composite",
        className: "LogSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricSpecification = {
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            supportedAggregationTypes: {
                serializedName: "supportedAggregationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            supportedTimeGrainTypes: {
                serializedName: "supportedTimeGrainTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            lockAggregationType: {
                serializedName: "lockAggregationType",
                type: {
                    name: "String"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DimensionProperties"
                        }
                    }
                }
            },
            fillGapWithZero: {
                serializedName: "fillGapWithZero",
                type: {
                    name: "Boolean"
                }
            },
            internalMetricName: {
                serializedName: "internalMetricName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DimensionProperties = {
    type: {
        name: "Composite",
        className: "DimensionProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            toBeExportedForShoebox: {
                serializedName: "toBeExportedForShoebox",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SecretCreateOrUpdateParameters = {
    type: {
        name: "Composite",
        className: "SecretCreateOrUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SecretProperties"
                }
            }
        }
    }
};
const SecretProperties = {
    type: {
        name: "Composite",
        className: "SecretProperties",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            secretUri: {
                serializedName: "secretUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            secretUriWithVersion: {
                serializedName: "secretUriWithVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Attributes = {
    type: {
        name: "Composite",
        className: "Attributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            notBefore: {
                serializedName: "nbf",
                type: {
                    name: "UnixTime"
                }
            },
            expires: {
                serializedName: "exp",
                type: {
                    name: "UnixTime"
                }
            },
            created: {
                serializedName: "created",
                readOnly: true,
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                serializedName: "updated",
                readOnly: true,
                type: {
                    name: "UnixTime"
                }
            }
        }
    }
};
const SecretPatchParameters = {
    type: {
        name: "Composite",
        className: "SecretPatchParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SecretPatchProperties"
                }
            }
        }
    }
};
const SecretPatchProperties = {
    type: {
        name: "Composite",
        className: "SecretPatchProperties",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            }
        }
    }
};
const SecretListResult = {
    type: {
        name: "Composite",
        className: "SecretListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Secret"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Key = {
    type: {
        name: "Composite",
        className: "Key",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { attributes: {
                serializedName: "properties.attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            }, kty: {
                serializedName: "properties.kty",
                type: {
                    name: "String"
                }
            }, keyOps: {
                serializedName: "properties.keyOps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, keySize: {
                serializedName: "properties.keySize",
                type: {
                    name: "Number"
                }
            }, curveName: {
                serializedName: "properties.curveName",
                type: {
                    name: "String"
                }
            }, keyUri: {
                serializedName: "properties.keyUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, keyUriWithVersion: {
                serializedName: "properties.keyUriWithVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const Secret = {
    type: {
        name: "Composite",
        className: "Secret",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SecretProperties"
                }
            } })
    }
};
const ManagedHsm = {
    type: {
        name: "Composite",
        className: "ManagedHsm",
        modelProperties: Object.assign(Object.assign({}, ManagedHsmResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ManagedHsmProperties"
                }
            } })
    }
};
const MhsmPrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "MhsmPrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, ManagedHsmResource.type.modelProperties), { etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "MhsmPrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "MhsmPrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            } })
    }
};
const MhsmPrivateLinkResource = {
    type: {
        name: "Composite",
        className: "MhsmPrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, ManagedHsmResource.type.modelProperties), { groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const SecretAttributes = {
    type: {
        name: "Composite",
        className: "SecretAttributes",
        modelProperties: Object.assign({}, Attributes.type.modelProperties)
    }
};
const PrivateEndpointConnectionsPutHeaders = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionsPutHeaders",
        modelProperties: {
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionsDeleteHeaders",
        modelProperties: {
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmPrivateEndpointConnectionsPutHeaders = {
    type: {
        name: "Composite",
        className: "MhsmPrivateEndpointConnectionsPutHeaders",
        modelProperties: {
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmPrivateEndpointConnectionsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "MhsmPrivateEndpointConnectionsDeleteHeaders",
        modelProperties: {
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    KeyCreateParameters: KeyCreateParameters,
    KeyProperties: KeyProperties,
    KeyAttributes: KeyAttributes,
    Resource: Resource,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    KeyListResult: KeyListResult,
    VaultCreateOrUpdateParameters: VaultCreateOrUpdateParameters,
    VaultProperties: VaultProperties,
    Sku: Sku,
    AccessPolicyEntry: AccessPolicyEntry,
    Permissions: Permissions,
    NetworkRuleSet: NetworkRuleSet,
    IPRule: IPRule,
    VirtualNetworkRule: VirtualNetworkRule,
    PrivateEndpointConnectionItem: PrivateEndpointConnectionItem,
    PrivateEndpoint: PrivateEndpoint,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    Vault: Vault,
    SystemData: SystemData,
    VaultPatchParameters: VaultPatchParameters,
    VaultPatchProperties: VaultPatchProperties,
    VaultAccessPolicyParameters: VaultAccessPolicyParameters,
    VaultAccessPolicyProperties: VaultAccessPolicyProperties,
    VaultListResult: VaultListResult,
    DeletedVaultListResult: DeletedVaultListResult,
    DeletedVault: DeletedVault,
    DeletedVaultProperties: DeletedVaultProperties,
    ResourceListResult: ResourceListResult,
    VaultCheckNameAvailabilityParameters: VaultCheckNameAvailabilityParameters,
    CheckNameAvailabilityResult: CheckNameAvailabilityResult,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    ManagedHsmProperties: ManagedHsmProperties,
    MhsmNetworkRuleSet: MhsmNetworkRuleSet,
    MhsmipRule: MhsmipRule,
    MhsmVirtualNetworkRule: MhsmVirtualNetworkRule,
    MhsmPrivateEndpointConnectionItem: MhsmPrivateEndpointConnectionItem,
    MhsmPrivateEndpoint: MhsmPrivateEndpoint,
    MhsmPrivateLinkServiceConnectionState: MhsmPrivateLinkServiceConnectionState,
    ManagedHsmResource: ManagedHsmResource,
    ManagedHsmSku: ManagedHsmSku,
    ManagedHsmError: ManagedHsmError,
    ErrorModel: ErrorModel,
    ManagedHsmListResult: ManagedHsmListResult,
    MhsmPrivateEndpointConnectionsListResult: MhsmPrivateEndpointConnectionsListResult,
    DeletedManagedHsmListResult: DeletedManagedHsmListResult,
    DeletedManagedHsm: DeletedManagedHsm,
    DeletedManagedHsmProperties: DeletedManagedHsmProperties,
    MhsmPrivateLinkResourceListResult: MhsmPrivateLinkResourceListResult,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    ServiceSpecification: ServiceSpecification,
    LogSpecification: LogSpecification,
    MetricSpecification: MetricSpecification,
    DimensionProperties: DimensionProperties,
    SecretCreateOrUpdateParameters: SecretCreateOrUpdateParameters,
    SecretProperties: SecretProperties,
    Attributes: Attributes,
    SecretPatchParameters: SecretPatchParameters,
    SecretPatchProperties: SecretPatchProperties,
    SecretListResult: SecretListResult,
    Key: Key,
    PrivateEndpointConnection: PrivateEndpointConnection,
    PrivateLinkResource: PrivateLinkResource,
    Secret: Secret,
    ManagedHsm: ManagedHsm,
    MhsmPrivateEndpointConnection: MhsmPrivateEndpointConnection,
    MhsmPrivateLinkResource: MhsmPrivateLinkResource,
    SecretAttributes: SecretAttributes,
    PrivateEndpointConnectionsPutHeaders: PrivateEndpointConnectionsPutHeaders,
    PrivateEndpointConnectionsDeleteHeaders: PrivateEndpointConnectionsDeleteHeaders,
    MhsmPrivateEndpointConnectionsPutHeaders: MhsmPrivateEndpointConnectionsPutHeaders,
    MhsmPrivateEndpointConnectionsDeleteHeaders: MhsmPrivateEndpointConnectionsDeleteHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: KeyCreateParameters
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vaultName = {
    parameterPath: "vaultName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9-]{3,24}$")
        },
        serializedName: "vaultName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const keyName = {
    parameterPath: "keyName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9-]{1,127}$")
        },
        serializedName: "keyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-10-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const keyVersion = {
    parameterPath: "keyVersion",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-fA-F0-9]{32}$")
        },
        serializedName: "keyVersion",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: VaultCreateOrUpdateParameters
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: VaultPatchParameters
};
const vaultName1 = {
    parameterPath: "vaultName",
    mapper: {
        serializedName: "vaultName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: VaultAccessPolicyParameters
};
const operationKind = {
    parameterPath: "operationKind",
    mapper: {
        serializedName: "operationKind",
        required: true,
        type: {
            name: "Enum",
            allowedValues: ["add", "replace", "remove"]
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: "filter",
    mapper: {
        defaultValue: "resourceType eq 'Microsoft.KeyVault/vaults'",
        isConstant: true,
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2015-11-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const vaultName2 = {
    parameterPath: "vaultName",
    mapper: VaultCheckNameAvailabilityParameters
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const properties = {
    parameterPath: "properties",
    mapper: PrivateEndpointConnection
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: ManagedHsm
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const properties1 = {
    parameterPath: "properties",
    mapper: MhsmPrivateEndpointConnection
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: SecretCreateOrUpdateParameters
};
const secretName = {
    parameterPath: "secretName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9-]{1,127}$")
        },
        serializedName: "secretName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: SecretPatchParameters
};
const secretName1 = {
    parameterPath: "secretName",
    mapper: {
        serializedName: "secretName",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Keys operations. */
class KeysImpl {
    /**
     * Initialize a new instance of the class Keys class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the keys in the specified key vault.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the keys to be retrieved.
     * @param options The options parameters.
     */
    list(resourceGroupName, vaultName, options) {
        const iter = this.listPagingAll(resourceGroupName, vaultName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, vaultName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, vaultName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, vaultName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, vaultName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the versions of the specified key in the specified key vault.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the key versions to be retrieved.
     * @param keyName The name of the key versions to be retrieved.
     * @param options The options parameters.
     */
    listVersions(resourceGroupName, vaultName, keyName, options) {
        const iter = this.listVersionsPagingAll(resourceGroupName, vaultName, keyName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listVersionsPagingPage(resourceGroupName, vaultName, keyName, options);
            }
        };
    }
    listVersionsPagingPage(resourceGroupName, vaultName, keyName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVersionsPagingPage_1() {
            let result = yield tslib.__await(this._listVersions(resourceGroupName, vaultName, keyName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listVersionsNext(resourceGroupName, vaultName, keyName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listVersionsPagingAll(resourceGroupName, vaultName, keyName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVersionsPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listVersionsPagingPage(resourceGroupName, vaultName, keyName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates the first version of a new key if it does not exist. If it already exists, then the existing
     * key is returned without any write operations being performed. This API does not create subsequent
     * versions, and does not update existing keys.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the key vault which contains the key to be created.
     * @param keyName The name of the key to be created.
     * @param parameters The parameters used to create the specified key.
     * @param options The options parameters.
     */
    createIfNotExist(resourceGroupName, vaultName, keyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, keyName, parameters, options }, createIfNotExistOperationSpec);
    }
    /**
     * Gets the current version of the specified key from the specified key vault.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the key to be retrieved.
     * @param keyName The name of the key to be retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, keyName, options }, getOperationSpec);
    }
    /**
     * Lists the keys in the specified key vault.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the keys to be retrieved.
     * @param options The options parameters.
     */
    _list(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listOperationSpec);
    }
    /**
     * Gets the specified version of the specified key in the specified key vault.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the key version to be retrieved.
     * @param keyName The name of the key version to be retrieved.
     * @param keyVersion The version of the key to be retrieved.
     * @param options The options parameters.
     */
    getVersion(resourceGroupName, vaultName, keyName, keyVersion, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, keyName, keyVersion, options }, getVersionOperationSpec);
    }
    /**
     * Lists the versions of the specified key in the specified key vault.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the key versions to be retrieved.
     * @param keyName The name of the key versions to be retrieved.
     * @param options The options parameters.
     */
    _listVersions(resourceGroupName, vaultName, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, keyName, options }, listVersionsOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the keys to be retrieved.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, vaultName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, nextLink, options }, listNextOperationSpec);
    }
    /**
     * ListVersionsNext
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the key versions to be retrieved.
     * @param keyName The name of the key versions to be retrieved.
     * @param nextLink The nextLink from the previous successful call to the ListVersions method.
     * @param options The options parameters.
     */
    _listVersionsNext(resourceGroupName, vaultName, keyName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, keyName, nextLink, options }, listVersionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const createIfNotExistOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/keys/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Key
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        keyName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/keys/{keyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Key
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        keyName
    ],
    headerParameters: [accept],
    serializer
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/keys",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer
};
const getVersionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/keys/{keyName}/versions/{keyVersion}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Key
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        keyName,
        keyVersion
    ],
    headerParameters: [accept],
    serializer
};
const listVersionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/keys/{keyName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        keyName
    ],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listVersionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        keyName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Vaults operations. */
class VaultsImpl {
    /**
     * Initialize a new instance of the class Vaults class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List operation gets information about the vaults associated with the subscription and within the
     * specified resource group.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The List operation gets information about the vaults associated with the subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets information about the deleted vaults in a subscription.
     * @param options The options parameters.
     */
    listDeleted(options) {
        const iter = this.listDeletedPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listDeletedPagingPage(options);
            }
        };
    }
    listDeletedPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedPagingPage_1() {
            let result = yield tslib.__await(this._listDeleted(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listDeletedNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listDeletedPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listDeletedPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * The List operation gets information about the vaults associated with the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Create or update a key vault in the specified subscription.
     * @param resourceGroupName The name of the Resource Group to which the server belongs.
     * @param vaultName Name of the vault
     * @param parameters Parameters to create or update the vault
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vaultName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vaultName, parameters, options }, createOrUpdateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Create or update a key vault in the specified subscription.
     * @param resourceGroupName The name of the Resource Group to which the server belongs.
     * @param vaultName Name of the vault
     * @param parameters Parameters to create or update the vault
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vaultName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vaultName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a key vault in the specified subscription.
     * @param resourceGroupName The name of the Resource Group to which the server belongs.
     * @param vaultName Name of the vault
     * @param parameters Parameters to patch the vault
     * @param options The options parameters.
     */
    update(resourceGroupName, vaultName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, parameters, options }, updateOperationSpec);
    }
    /**
     * Deletes the specified Azure key vault.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName The name of the vault to delete
     * @param options The options parameters.
     */
    delete(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, deleteOperationSpec);
    }
    /**
     * Gets the specified Azure key vault.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName The name of the vault.
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, getOperationSpec$1);
    }
    /**
     * Update access policies in a key vault in the specified subscription.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName Name of the vault
     * @param operationKind Name of the operation
     * @param parameters Access policy to merge into the vault
     * @param options The options parameters.
     */
    updateAccessPolicy(resourceGroupName, vaultName, operationKind, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, operationKind, parameters, options }, updateAccessPolicyOperationSpec);
    }
    /**
     * The List operation gets information about the vaults associated with the subscription and within the
     * specified resource group.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * The List operation gets information about the vaults associated with the subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Gets information about the deleted vaults in a subscription.
     * @param options The options parameters.
     */
    _listDeleted(options) {
        return this.client.sendOperationRequest({ options }, listDeletedOperationSpec);
    }
    /**
     * Gets the deleted Azure key vault.
     * @param vaultName The name of the vault.
     * @param location The location of the deleted vault.
     * @param options The options parameters.
     */
    getDeleted(vaultName, location, options) {
        return this.client.sendOperationRequest({ vaultName, location, options }, getDeletedOperationSpec);
    }
    /**
     * Permanently deletes the specified vault. aka Purges the deleted Azure key vault.
     * @param vaultName The name of the soft-deleted vault.
     * @param location The location of the soft-deleted vault.
     * @param options The options parameters.
     */
    beginPurgeDeleted(vaultName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { vaultName, location, options }, purgeDeletedOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Permanently deletes the specified vault. aka Purges the deleted Azure key vault.
     * @param vaultName The name of the soft-deleted vault.
     * @param location The location of the soft-deleted vault.
     * @param options The options parameters.
     */
    beginPurgeDeletedAndWait(vaultName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPurgeDeleted(vaultName, location, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The List operation gets information about the vaults associated with the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * Checks that the vault name is valid and is not already in use.
     * @param vaultName The name of the vault.
     * @param options The options parameters.
     */
    checkNameAvailability(vaultName, options) {
        return this.client.sendOperationRequest({ vaultName, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListDeletedNext
     * @param nextLink The nextLink from the previous successful call to the ListDeleted method.
     * @param options The options parameters.
     */
    _listDeletedNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listDeletedNextOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Vault
        },
        201: {
            bodyMapper: Vault
        },
        202: {
            bodyMapper: Vault
        },
        204: {
            bodyMapper: Vault
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$1
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Vault
        },
        201: {
            bodyMapper: Vault
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName1
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Vault
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName1
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const updateAccessPolicyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/accessPolicies/{operationKind}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VaultAccessPolicyParameters
        },
        201: {
            bodyMapper: VaultAccessPolicyParameters
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        operationKind
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$1
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VaultListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/vaults",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VaultListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const listDeletedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/deletedVaults",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedVaultListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const getDeletedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/locations/{location}/deletedVaults/{vaultName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedVault
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        vaultName1,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const purgeDeletedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/locations/{location}/deletedVaults/{vaultName}/purge",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        vaultName1,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [top, filter, apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vaultName2,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$1
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VaultListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VaultListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listDeletedNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedVaultListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [top, filter, apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List operation gets information about the private endpoint connections associated with the
     * vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param options The options parameters.
     */
    listByResource(resourceGroupName, vaultName, options) {
        const iter = this.listByResourcePagingAll(resourceGroupName, vaultName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourcePagingPage(resourceGroupName, vaultName, options);
            }
        };
    }
    listByResourcePagingPage(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingPage_1() {
            let result = yield tslib.__await(this._listByResource(resourceGroupName, vaultName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceNext(resourceGroupName, vaultName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourcePagingAll(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourcePagingPage(resourceGroupName, vaultName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the specified private endpoint connection associated with the key vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the key
     *                                      vault.
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, privateEndpointConnectionName, options }, getOperationSpec$2);
    }
    /**
     * Updates the specified private endpoint connection associated with the key vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the key
     *                                      vault.
     * @param properties The intended state of private endpoint connection.
     * @param options The options parameters.
     */
    put(resourceGroupName, vaultName, privateEndpointConnectionName, properties, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            vaultName,
            privateEndpointConnectionName,
            properties,
            options
        }, putOperationSpec);
    }
    /**
     * Deletes the specified private endpoint connection associated with the key vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the key
     *                                      vault.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vaultName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vaultName, privateEndpointConnectionName, options }, deleteOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the specified private endpoint connection associated with the key vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the key
     *                                      vault.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vaultName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vaultName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The List operation gets information about the private endpoint connections associated with the
     * vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param options The options parameters.
     */
    _listByResource(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listByResourceOperationSpec);
    }
    /**
     * ListByResourceNext
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param nextLink The nextLink from the previous successful call to the ListByResource method.
     * @param options The options parameters.
     */
    _listByResourceNext(resourceGroupName, vaultName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, nextLink, options }, listByResourceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const putOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection,
            headersMapper: PrivateEndpointConnectionsPutHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: properties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        privateEndpointConnectionName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByResourceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByResourceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the private link resources supported for the key vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param options The options parameters.
     */
    listByVault(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listByVaultOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByVaultOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedHsms operations. */
class ManagedHsmsImpl {
    /**
     * Initialize a new instance of the class ManagedHsms class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List operation gets information about the managed HSM Pools associated with the subscription and
     * within the specified resource group.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The List operation gets information about the managed HSM Pools associated with the subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * The List operation gets information about the deleted managed HSMs associated with the subscription.
     * @param options The options parameters.
     */
    listDeleted(options) {
        const iter = this.listDeletedPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listDeletedPagingPage(options);
            }
        };
    }
    listDeletedPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedPagingPage_1() {
            let result = yield tslib.__await(this._listDeleted(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listDeletedNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listDeletedPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listDeletedPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Create or update a managed HSM Pool in the specified subscription.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param parameters Parameters to create or update the managed HSM Pool
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, parameters, options }, createOrUpdateOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Create or update a managed HSM Pool in the specified subscription.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param parameters Parameters to create or update the managed HSM Pool
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a managed HSM Pool in the specified subscription.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param parameters Parameters to patch the managed HSM Pool
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, name, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, parameters, options }, updateOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Update a managed HSM Pool in the specified subscription.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param parameters Parameters to patch the managed HSM Pool
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, name, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, name, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the specified managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name The name of the managed HSM Pool to delete
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, deleteOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the specified managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name The name of the managed HSM Pool to delete
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name The name of the managed HSM Pool.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$3);
    }
    /**
     * The List operation gets information about the managed HSM Pools associated with the subscription and
     * within the specified resource group.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * The List operation gets information about the managed HSM Pools associated with the subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * The List operation gets information about the deleted managed HSMs associated with the subscription.
     * @param options The options parameters.
     */
    _listDeleted(options) {
        return this.client.sendOperationRequest({ options }, listDeletedOperationSpec$1);
    }
    /**
     * Gets the specified deleted managed HSM.
     * @param name The name of the deleted managed HSM.
     * @param location The location of the deleted managed HSM.
     * @param options The options parameters.
     */
    getDeleted(name, location, options) {
        return this.client.sendOperationRequest({ name, location, options }, getDeletedOperationSpec$1);
    }
    /**
     * Permanently deletes the specified managed HSM.
     * @param name The name of the soft-deleted managed HSM.
     * @param location The location of the soft-deleted managed HSM.
     * @param options The options parameters.
     */
    beginPurgeDeleted(name, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { name, location, options }, purgeDeletedOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Permanently deletes the specified managed HSM.
     * @param name The name of the soft-deleted managed HSM.
     * @param location The location of the soft-deleted managed HSM.
     * @param options The options parameters.
     */
    beginPurgeDeletedAndWait(name, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPurgeDeleted(name, location, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
    /**
     * ListDeletedNext
     * @param nextLink The nextLink from the previous successful call to the ListDeleted method.
     * @param options The options parameters.
     */
    _listDeletedNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listDeletedNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$4 = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedHsm
        },
        201: {
            bodyMapper: ManagedHsm
        },
        202: {
            bodyMapper: ManagedHsm
        },
        204: {
            bodyMapper: ManagedHsm
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$4
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ManagedHsm
        },
        201: {
            bodyMapper: ManagedHsm
        },
        202: {
            bodyMapper: ManagedHsm
        },
        204: {
            bodyMapper: ManagedHsm
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsm
        },
        202: {},
        204: {},
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/managedHSMs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$4
};
const listDeletedOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/deletedManagedHSMs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedManagedHsmListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$4
};
const getDeletedOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/locations/{location}/deletedManagedHSMs/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedManagedHsm
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const purgeDeletedOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/locations/{location}/deletedManagedHSMs/{name}/purge",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listDeletedNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedManagedHsmListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing MhsmPrivateEndpointConnections operations. */
class MhsmPrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class MhsmPrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List operation gets information about the private endpoint connections associated with the
     * managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param options The options parameters.
     */
    listByResource(resourceGroupName, name, options) {
        const iter = this.listByResourcePagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourcePagingPage(resourceGroupName, name, options);
            }
        };
    }
    listByResourcePagingPage(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingPage_1() {
            let result = yield tslib.__await(this._listByResource(resourceGroupName, name, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourcePagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourcePagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The List operation gets information about the private endpoint connections associated with the
     * managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param options The options parameters.
     */
    _listByResource(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listByResourceOperationSpec$1);
    }
    /**
     * Gets the specified private endpoint connection associated with the managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the
     *                                      managed hsm pool.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, privateEndpointConnectionName, options }, getOperationSpec$4);
    }
    /**
     * Updates the specified private endpoint connection associated with the managed hsm pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the
     *                                      managed hsm pool.
     * @param properties The intended state of private endpoint connection.
     * @param options The options parameters.
     */
    put(resourceGroupName, name, privateEndpointConnectionName, properties, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            privateEndpointConnectionName,
            properties,
            options
        }, putOperationSpec$1);
    }
    /**
     * Deletes the specified private endpoint connection associated with the managed hsm pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the
     *                                      managed hsm pool.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, privateEndpointConnectionName, options }, deleteOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes the specified private endpoint connection associated with the managed hsm pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the
     *                                      managed hsm pool.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, name, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByResourceNext
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param nextLink The nextLink from the previous successful call to the ListByResource method.
     * @param options The options parameters.
     */
    _listByResourceNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listByResourceNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$5 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByResourceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MhsmPrivateEndpointConnectionsListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MhsmPrivateEndpointConnection
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateEndpointConnectionName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const putOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MhsmPrivateEndpointConnection,
            headersMapper: MhsmPrivateEndpointConnectionsPutHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: properties1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateEndpointConnectionName,
        name
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: MhsmPrivateEndpointConnection
        },
        201: {
            bodyMapper: MhsmPrivateEndpointConnection
        },
        202: {
            bodyMapper: MhsmPrivateEndpointConnection
        },
        204: {
            bodyMapper: MhsmPrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateEndpointConnectionName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByResourceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MhsmPrivateEndpointConnectionsListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing MhsmPrivateLinkResources operations. */
class MhsmPrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class MhsmPrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the private link resources supported for the managed hsm pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param options The options parameters.
     */
    listByMhsmResource(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listByMhsmResourceOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByMhsmResourceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MhsmPrivateLinkResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Key Vault Rest API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Key Vault Rest API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$7 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/providers/Microsoft.KeyVault/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Secrets operations. */
class SecretsImpl {
    /**
     * Initialize a new instance of the class Secrets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List operation gets information about the secrets in a vault.  NOTE: This API is intended for
     * internal use in ARM deployments. Users should use the data-plane REST service for interaction with
     * vault secrets.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName The name of the vault.
     * @param options The options parameters.
     */
    list(resourceGroupName, vaultName, options) {
        const iter = this.listPagingAll(resourceGroupName, vaultName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, vaultName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, vaultName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, vaultName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, vaultName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create or update a secret in a key vault in the specified subscription.  NOTE: This API is intended
     * for internal use in ARM deployments. Users should use the data-plane REST service for interaction
     * with vault secrets.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName Name of the vault
     * @param secretName Name of the secret
     * @param parameters Parameters to create or update the secret
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, vaultName, secretName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, secretName, parameters, options }, createOrUpdateOperationSpec$2);
    }
    /**
     * Update a secret in the specified subscription.  NOTE: This API is intended for internal use in ARM
     * deployments.  Users should use the data-plane REST service for interaction with vault secrets.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName Name of the vault
     * @param secretName Name of the secret
     * @param parameters Parameters to patch the secret
     * @param options The options parameters.
     */
    update(resourceGroupName, vaultName, secretName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, secretName, parameters, options }, updateOperationSpec$2);
    }
    /**
     * Gets the specified secret.  NOTE: This API is intended for internal use in ARM deployments. Users
     * should use the data-plane REST service for interaction with vault secrets.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName The name of the vault.
     * @param secretName The name of the secret.
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, secretName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, secretName, options }, getOperationSpec$5);
    }
    /**
     * The List operation gets information about the secrets in a vault.  NOTE: This API is intended for
     * internal use in ARM deployments. Users should use the data-plane REST service for interaction with
     * vault secrets.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName The name of the vault.
     * @param options The options parameters.
     */
    _list(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName The name of the vault.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, vaultName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$8 = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/secrets/{secretName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Secret
        },
        201: {
            bodyMapper: Secret
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        secretName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/secrets/{secretName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Secret
        },
        201: {
            bodyMapper: Secret
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        secretName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/secrets/{secretName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Secret
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName1,
        secretName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/secrets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        vaultName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class KeyVaultManagementClient extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the KeyVaultManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId Subscription credentials which uniquely identify Microsoft Azure subscription.
     *                       The subscription ID forms part of the URI for every service call.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-keyvault/2.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2021-10-01";
        this.keys = new KeysImpl(this);
        this.vaults = new VaultsImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.managedHsms = new ManagedHsmsImpl(this);
        this.mhsmPrivateEndpointConnections = new MhsmPrivateEndpointConnectionsImpl(this);
        this.mhsmPrivateLinkResources = new MhsmPrivateLinkResourcesImpl(this);
        this.operations = new OperationsImpl(this);
        this.secrets = new SecretsImpl(this);
    }
}

exports.KeyVaultManagementClient = KeyVaultManagementClient;
//# sourceMappingURL=index.js.map
